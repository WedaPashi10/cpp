# Move Assignement Operator

Before we leap to Move Assignment operator, lets revisit Move Constructor.

A move constructor of a class `Foo` is a non-template constructor with first argument as `Foo&&`, `const Foo&&`,
`volatile Foo&&` or a `const volatile Foo&&` -- which in fact are traits of rvalue references.

Syntax:

    className (className &&)
    className (className &&) = default;
    className (className &&) = delete;

Meaning:
 - Typical declaration of a move constructor
 - FOrcing a move constructor to be generated by the compiler
 - Avoiding implicit move constructor

If `bar` is an object of class `Foo`. And you intend to have `baz` as a copied object of `bar`, a typical copy constructor is used --

    Foo bar;
    // Some code

    Foo baz(bar); // Calls the copy contructor

To do this the 'move' way --

    Foo bar;
    // Some code

    baz = std::move(bar); // Calls the move constructor

## Move Assignment Operator

A move assignment operator of a class `Foo` is a non-template non-static member function with the name `operator=` that
takes exactly one parameter of type `Foo&&`, `const Foo&&`, `volatile Foo&&` or `const volatile Foo&&`.

Syntax:

    className& className::operator=(className&&) 
    className& className::operator=(className&&) = default;
    className& className::operator=(className&&) = delete;

The move assignment operator is called whenever it is selected by overload resolution, e.g. when an object appears on the left-hand side of an assignment expression, where the right-hand side is an rvalue of the same or implicitly convertible type.

Move assignment operators typically "steal" the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc.), rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state.

***
### Program output:

    In default constructor
    10
    In default constructor
    In Move Assignment Operator
    10

